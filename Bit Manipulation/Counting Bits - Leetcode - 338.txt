Leetcode - 338

Link - https://leetcode.com/problems/counting-bits/description/

338 - Counting Bits

Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.

 

Example 1:

Input: n = 2
Output: [0,1,1]
Explanation:
0 --> 0
1 --> 1
2 --> 10
Example 2:

Input: n = 5
Output: [0,1,1,2,1,2]
Explanation:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
 

Constraints:

0 <= n <= 105


Solution in CPP:

class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> ans(n+1);
        for(int i=1;i<=n;i++)
        {
            if(i%2!=0)
            {
                ans[i] = 1 + ans[i/2];
            }
            else
            {
                ans[i] = ans[i/2];
            }
        }
        return ans;
    }
};


Explanation:

First declare a vector (ans) with a size of n+1
the default value of vector will be 0

then using loop run from 1 to n(inclusive)

if i is odd then add 1 and ans[i/2] and store it in ans[i]
if i is even then just assign ans[i/2] to ans[i]

atlast return the ans vector it will be the answer

Example 1:

Input: n = 5

Iterations:

1) i = 1 => odd
   so, ans[i] = 1 + ans[i/2] => ans[i] = 1 + ans[1/2] => ans[i] = 1 + ans[0] => ans[i] = 1 + 0 => ans[i] = 1

2) i = 2 => even
   so, ans[i] = ans[i/2] => ans[i] = ans[2/2] => ans[i] = ans[1] => ans[i] = 1 => ans[i] = 1

3) i = 3 => odd
   so, ans[i] = 1 + ans[i/2] => ans[i] = 1 + ans[3/2] => ans[i] = 1 + ans[1] => ans[i] = 1 + 1 => ans[i] = 2

4) i = 4 => even
   so, ans[i] = ans[i/2] => ans[i] = ans[4/2] => ans[i] = ans[2] => ans[i] = 1 => ans[i] = 1

5) i = 5 => odd
   so, ans[i] = 1 + ans[i/2] => ans[i] = 1 + ans[5/2] => ans[i] = 1 + ans[2] => ans[i] = 1 + 1 => ans[i] = 2

Comes out of loop 
return ans = [0, 1, 1, 2, 1, 2]

Every number i in binary is formed by taking i/2 (which removes the last bit) and adding one new last bit. 
The number of 1s in i is therefore equal to the number of 1s in i/2,
plus 1 if the removed last bit was 1 (odd number), or plus 0 if it was 0 (even number). 
This works because dividing by 2 in binary simply shifts right and preserves all previous bitsâ€™ count.