Leetcode - 1734

Link - https://leetcode.com/problems/decode-xored-permutation/description/

1734 - Decode XORed Permutation

There is an integer array perm that is a permutation of the first n positive integers, where n is always odd.

It was encoded into another integer array encoded of length n - 1, such that encoded[i] = perm[i] XOR perm[i + 1]. For example, if perm = [1,3,2], then encoded = [2,1].

Given the encoded array, return the original array perm. It is guaranteed that the answer exists and is unique.

 

Example 1:

Input: encoded = [3,1]
Output: [1,2,3]
Explanation: If perm = [1,2,3], then encoded = [1 XOR 2,2 XOR 3] = [3,1]
Example 2:

Input: encoded = [6,5,4,6]
Output: [2,4,1,5,3]
 

Constraints:

3 <= n < 105
n is odd.
encoded.length == n - 1


Solution in CPP:

class Solution {
public:
    vector<int> decode(vector<int>& encoded) {
        int n = encoded.size()+1;
        int t = 0;
        vector<int> perm;
        if(n%4==0)
        {
            t = n;
        }
        else if(n%4==1)
        {
            t = 1;
        }
        else if(n%4==2)
        {
            t = n + 1;
        }
        else if(n%4==3)
        {
            t = 0;
        }
        int xorenc = 0;
        for(int i=0;i<n-1;i+=2)
        {
            xorenc^=encoded[i];
        }
        int el = t ^ xorenc;
        perm.push_back(el);
        for(int i = n-2;i>=0;i--)
        {
            el = el ^ encoded[i];
            perm.push_back(el);
        }
        reverse(perm.begin(), perm.end());
        return perm;
    }
};


Explanation:

first set n = encoded size + 1
because the size of original array is always odd and size of encoded array is always even so encoded size + 1 
then for storing the value of xor for a range set t = 0
then declare a vector for returning the original array values called perm

then the process of xor for a range takes place 

       n    XOR(1 to n)
0^1    1    1
1^2    2    3
2^3    3    0
3^4    4    4
4^5    5    1
5^6    6    7
6^7    7    0
7^8    8    8

this is the pattern of xor for a range 

here we can see the pattern that,
1st position we get 1 and in 5th position we again get 1 - here the difference between the positions is 4
3rd position we get 0 and in 7th position we again get 0 - here the difference between the positions is 4
2st position we get 3 and in 6th position we get 7 - here the difference between the positions is 4 and the difference between value is also 4
4th position we get 4 and in 8th position we get 8 - here the difference between the positions is 4 and the difference between value is also 4

so here we can also see the pattern of answers we are getting 
for 1st position as starting point we get 1 as answer
for 2nd position as starting point we get 3 as answer which we can take as let's take 2 as i then answer is i+1 so i+1 is the answer
for 3rd position as starting point we get 0 as answer 
for 4th position as starting point we get 4th multiple as answer

so to get the xor for range 
we can find it by n%4 
if ans = 0 then return n
if ans = 1 then return 1
if ans = 2 then return n + 1
if ans = 3 then return 0

after finding it store it in t

then declare a variable xorenc = 0


now we are going to find the value last element in the original array for that we need to do xor for the t(xor for a range) with xorenc

xorenc is the xor of all the other answers of xor except the last element 

so just xor the values in encoded array but with increment of 2 only then we will get the xor of every element except last
using loop run from i = 0  to n - 1
increment i = i + 2
xorenc = encoded[i]^xorenc

now after getting xorenc,
xor xorenc with t (i.e) xorenc^t and store it in new variable el

now we got one unique value that is the last value of original array 

push it to the vector

as we know value of encoded array is the xor of two values as we have one value 
xor encoded array value with the unique element to get the previous value in original array using loop 
run loop from n-2 to 0
(n-2 because we already have last value)
increment loop variable by 1

xor it iteratively and push it to the vector
after coming out of the loop ,

reverse the vector because the values stores will be in reverse order
so reverse it to get original array
then return it 


Example 1:

Input: encoded = [3,1]

here encoded.size = 2
so n = encoded.size + 1 = 3

xor for a range is 
n%4 = 3%4 = 3 which is 0
so t = 0

now xorenc 
as we have only two values if we increment 2 from 0th position we get out of encoded array so only first value will get considered

so xorenc = 3
el = t ^ xorenc = 0 ^ 3 = 3
so el  = 3
push it to the vector 

now we get the value of last value in original array

now run a loop from i = n-2 to 0 and decrement i by 1
(n-2 because n = encoded.size+1)

inside loop xor el with encoded[i] (i.e el^encoded[i]) and store it in el and push it to vector perm

Iterations:

1) el = 3 , encoded[i] = 1
el^encoded[i] = 3 ^ 1 = 2
el = 2
push el to perm vector


2) el = 2 , encoded[i] = 3
el^encoded[i] = 2 ^ 3 = 1
el = 1
push el to perm vector

we get the answer (i.e) original array in reverse order [3, 2, 1]

so reverse it and return the vector perm and that is the answer [1, 2, 3]