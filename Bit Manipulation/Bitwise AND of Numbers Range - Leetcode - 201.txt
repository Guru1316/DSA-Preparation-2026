Leetcode - 201

Link - https://leetcode.com/problems/bitwise-and-of-numbers-range/description/

201 - Bitwise AND of Numbers Range

Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.

 

Example 1:

Input: left = 5, right = 7
Output: 4
Example 2:

Input: left = 0, right = 0
Output: 0
Example 3:

Input: left = 1, right = 2147483647
Output: 0
 

Constraints:

0 <= left <= right <= 231 - 1


Solution in CPP:

class Solution {
public:
    int rangeBitwiseAnd(int left, int right) {
        int c = 0;
        while(left!=right)
        {
            c++;
            left >>= 1;
            right >>= 1;
        }
        return left <<= c;
    }
};


Explanation:

first set c = 0;

then run a loop until left and right becomes same value 
until then increment c by 1 for every iteration and right shift(>>) left and right by 1 

if left == right then it comes out of loop we will have a value for c now left shift the value of left with the value of c
and return left and that is the answer


Example 1:

Input: left = 5, right = 7

Iterations:

c = 0
1) (left != right) => 5!=7 (true) so loop executes
   
   increment c => c = 1
   left >> = 1 => left = 5 >> 1 => 0101 >> 1 => 0010 => 2
   right >> = 1 => right = 7 >> 1 => 0111 >> 1 => 0011 => 3

c = 1
2) (left != right) => 2!=3 (true) so loop executes
   
   increment c => c = 2
   left >> = 1 => left = 2 >> 1 => 0010 >> 1 => 0001 => 1
   right >> = 1 => right = 3 >> 1 => 0011 >> 1 => 0001 => 1

3) (left != right) => 1!=1 (false) so gets out of loop
   

Now left shift the value of left with the value of c (lef shifting add zeros to the right of oth position bit)

left = 1
c = 2

left = left << c => left = 1 << 2 => 0001 << 2 => 0100 => 4

return left which is 4 and that is the answer

This happens because,

shifting both numbers right until equal to find their common prefix, counting shifts 
Then shifting left back to restore the result
This works because differing bits in the range always produce 0 in AND

if a column or ith position bit of any number in the range is 0 then for sure the final answer bit after (&) operation will also be 0 in that ith position
so we are finding the common prefix first using the above logic and then we add zeros to the right of that prefix in the count of c which we incremented while right shift